from datetime import date, datetime, time, timedelta, tzinfo
from typing import ClassVar, Literal, Self, SupportsIndex

from .date import Date
from .period import Period
from .time import Time
from .tz.timezone import Timezone

class DateTime(datetime, Date):
    min: ClassVar[DateTime]
    max: ClassVar[DateTime]
    EPOCH: ClassVar[DateTime]
    @classmethod
    def now(cls, tz: str | Timezone | None = ...) -> DateTime: ...
    @classmethod
    def utcnow(cls) -> DateTime: ...
    @classmethod
    def today(cls) -> DateTime: ...
    @classmethod
    def strptime(cls, time: str, fmt: str) -> DateTime: ...
    def set(
        self,
        year: int | None = ...,
        month: int | None = ...,
        day: int | None = ...,
        hour: int | None = ...,
        minute: int | None = ...,
        second: int | None = ...,
        microsecond: int | None = ...,
        tz: str | float | Timezone | None = ...,
    ) -> DateTime: ...
    @property
    def float_timestamp(self) -> float: ...
    @property
    def int_timestamp(self) -> int: ...
    @property
    def offset(self) -> int: ...
    @property
    def offset_hours(self) -> int: ...
    @property
    def timezone(self) -> Timezone | None: ...
    @property
    def tz(self) -> Timezone | None: ...
    @property
    def timezone_name(self) -> str | None: ...
    @property
    def age(self) -> int: ...
    def is_local(self) -> bool: ...
    def is_utc(self) -> bool: ...
    def is_dst(self) -> bool: ...
    def get_offset(self) -> int: ...
    def date(self) -> Date: ...
    def time(self) -> Time: ...
    def naive(self) -> Self: ...
    def on(self, year: int, month: int, day: int) -> Self: ...
    def at(
        self, hour: int, minute: int = ..., second: int = ..., microsecond: int = ...
    ) -> Self: ...
    def in_timezone(self, tz: str | Timezone) -> Self: ...
    def in_tz(self, tz: str | Timezone) -> Self: ...
    def to_time_string(self) -> str: ...
    def to_datetime_string(self) -> str: ...
    def to_day_datetime_string(self) -> str: ...
    def to_atom_string(self) -> str: ...
    def to_cookie_string(self) -> str: ...
    def to_iso8601_string(self) -> str: ...
    def to_rfc822_string(self) -> str: ...
    def to_rfc850_string(self) -> str: ...
    def to_rfc1036_string(self) -> str: ...
    def to_rfc1123_string(self) -> str: ...
    def to_rfc2822_string(self) -> str: ...
    def to_rfc3339_string(self) -> str: ...
    def to_rss_string(self) -> str: ...
    def to_w3c_string(self) -> str: ...
    def closest(self, dt1: datetime, dt2: datetime, *dts: datetime) -> DateTime: ...
    def farthest(self, dt1: datetime, dt2: datetime, *dts: datetime) -> DateTime: ...
    def is_future(self) -> bool: ...
    def is_past(self) -> bool: ...
    def is_long_year(self) -> bool: ...
    def is_same_day(self, dt: datetime) -> bool: ...
    def is_anniversary(self, dt: datetime | None = ...) -> bool: ...
    def is_birthday(self, dt: datetime | None = ...) -> bool: ...
    def add(
        self,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ) -> Self: ...
    def subtract(
        self,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ) -> Self: ...
    def diff(self, dt: datetime | None = ..., abs: bool = ...) -> Period: ...
    def diff_for_humans(
        self,
        other: datetime | None = ...,
        absolute: bool = ...,
        locale: str | None = ...,
    ) -> str: ...
    def start_of(
        self,
        unit: Literal[
            'second',
            'minute',
            'hour',
            'day',
            'week',
            'month',
            'year',
            'decade',
            'century',
        ],
    ) -> Self: ...
    def end_of(
        self,
        unit: Literal[
            'second',
            'minute',
            'hour',
            'day',
            'week',
            'month',
            'year',
            'decade',
            'century',
        ],
    ) -> Self: ...
    def next(self, day_of_week: int | None = ..., keep_time: bool = ...) -> Self: ...
    def previous(
        self, day_of_week: int | None = ..., keep_time: bool = ...
    ) -> Self: ...
    def first_of(
        self, unit: Literal['month', 'quarter', 'year'], day_of_week: int | None = ...
    ) -> Self: ...
    def last_of(
        self, unit: Literal['month', 'quarter', 'year'], day_of_week: int | None = ...
    ) -> Self: ...
    def nth_of(
        self,
        unit: Literal['month', 'quarter', 'year'],
        nth: int,
        day_of_week: int | None,
    ) -> Self: ...
    def average(self, dt: datetime | None = ...) -> Self: ...
    def __sub__(self, other: timedelta | datetime) -> Self: ...
    def __rsub__(self, other: datetime) -> Self: ...
    def __add__(self, other: timedelta) -> Self: ...
    def __radd__(self, other: timedelta) -> Self: ...
    @classmethod
    def fromtimestamp(cls, __timestamp: float, tz: tzinfo | None = ...) -> DateTime: ...
    @classmethod
    def utcfromtimestamp(cls, t: float) -> DateTime: ...
    @classmethod
    def fromordinal(cls, n: int) -> DateTime: ...
    @classmethod
    def combine(cls, date: date, time: time) -> DateTime: ...
    def astimezone(self, tz: tzinfo | None = ...) -> DateTime: ...
    def replace(
        self,
        year: SupportsIndex = ...,
        month: SupportsIndex = ...,
        day: SupportsIndex = ...,
        hour: SupportsIndex = ...,
        minute: SupportsIndex = ...,
        second: SupportsIndex = ...,
        microsecond: SupportsIndex = ...,
        tzinfo: tzinfo | None = ...,
        fold: int = ...,
    ) -> DateTime: ...
    def __getnewargs__(self) -> tuple[Self]: ...
    def __reduce__(
        self,
    ) -> tuple[type[Self], tuple[int, int, int, int, int, int, int, tzinfo]]: ...
    def __reduce_ex__(
        self, protocol: int
    ) -> tuple[type[Self], tuple[int, int, int, int, int, int, int, tzinfo]]: ...
